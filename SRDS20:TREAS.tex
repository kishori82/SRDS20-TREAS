


\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}


\usepackage{tikz}
\usepackage{amsmath}

%-------------------------------------------------------------------------------
% MACRO
%-------------------------------------------------------------------------------
\usepackage{microtype}
\usepackage{amssymb,amsmath,multicol,amsthm}
\usepackage{graphicx,url}
\usepackage{color,setspace,enumitem}
\usepackage{epstopdf}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{times}
\usepackage{ulem}
%\usepackage[left=.9in, right=.9in, top=.9in, bottom=.9in]{geometry}

\usepackage[ruled]{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{ioa_code}
\usepackage{scalerel,stackengine}


\newcommand{\myemph}[1]{{\it #1}}
%\newcommand{\nn}[1]{{\blue{#1}}}
\newcommand{\nn}[1]{{{#1}}}
%\newcommand{\nnrev}[2]{\sout{}{\blue{#2}}}
\newcommand{\nnrev}[2]{\sout{}{{#2}}}
%\newcommand{\kmk}[1]{{\red{#1}}}
\newcommand{\kmk}[1]{{{#1}}}

%\renewcommand{\cg}[1]{{\textcolor{blue}{#1}}}
\newtheorem*{theorem}{{\bf Theorem}}
\newtheorem*{lemma}{{\bf Lemma}}


%\newcommand{\myparagraph}[1]{\paragraph*{#1}}
\newcommand{\myparagraph}[1]{\smallskip\noindent{\textbf{#1}}}

%Coding Stuff
\newcommand{\states}[1]{{ {states}(#1)}}
\newcommand{\startstates}[1]{{ {start}(#1)}}
\newcommand{\sig}[1]{{ {sig}(#1)}}
\newcommand{\inactions}[1]{{ {in}(#1)}}	
\newcommand{\outactions}[1]{{ {out}(#1)}}
\newcommand{\intactions}[1]{{ {int}(#1)}}
\newcommand{\extactions}[1]{{ {ext}(#1)}}
\newcommand{\trans}[1]{{ {trans}(#1)}}
\newcommand{\encode}[3]{{ {encode}_{#1, #2}(#3)}}
\newcommand{\decode}[3]{{ {decode}_{#1, #2}(#3)}}
\newcommand{\cvec}[2]{\mathbf{c}^{#1}_{#2}}
\newcommand{\atT}[2]{#1|_{#2}}
\newcommand{\status}[1]{#1.status}
\newcommand{\config}[1]{#1.cfg}
%\newcommand{\CASOPT}{{\sc TREAS}} 
\newcommand{\GetTag}{{ \it{get-tag}}}
\newcommand{\QueryTag}{\text{\sc{query-tag}}}
\newcommand{\PutData}{{ \it{put-data}}}
\newcommand{\PutDataTag}{\text{\sc{put-data}}}
\newcommand{\GetData}{{ \it{get-data}}}
\newcommand{\QueryTagData}{\text{\sc{query-tag-data}}}
\newcommand{\GetTagResp}{{ \it{get-tag-resp}}}
\newcommand{\GetDataResp}{{ \it{get-data-resp}}}
\newcommand{\PutDataResp}{{ \it{put-data-resp}}}
\newcommand{\InitRep}{{ \it{init-repair}}}
\newcommand{\RepairTagData}{\text{\sc{repair-tag-data}}}
\newcommand{\InitRepResp}{{ \it{init-repair-resp}}}
\newcommand{\CodedElementTag}{\text{\sc{code-elements}}}
\newcommand{\Coded}{code\act{-}elems}
\newcommand{\ConfirmDataTag}{\text{\sc{confirm-data}}}
\newcommand{\QueryList}{\text{\sc{query-list}}}
\newcommand{\RepairList}{\text{\sc{repair-list}}}
\newcommand{\optag}[1]{{tag(#1)}}
\newcommand{\gseq}{{\mathcal{G}_L}}

\newcommand{\smdelay}{d}
\newcommand{\lgdelay}{D}
\newcommand{\opdelay}[1]{T(#1)}
\newcommand{\opdelaymin}[1]{T_{min}(#1)}
\newcommand{\opdelaymax}[1]{T_{max}(#1)}
\newcommand{\seqlen}{\lambda}
\newcommand{\emp}[1]{{\it #1}}
\newcommand{\commentOut}[1]{}

\newcommand{\treasmod}{{\sc Treas}}
\newcommand{\treasCassandra}{{\sc Treas-Cassandra}}

\algblockdefx[Operation]{Operation}{EndOperation}%
[2]{{\bf operation} $\act{#1}$(#2)}%
{{\bf end operation}}
\algblockdefx[Procedure]{Procedure}{EndProcedure}%
[2]{{\bf procedure} $\act{#1}$(#2)}%
{{\bf end procedure}}


\algblockdefx[Receive]{Receive}{EndReceive}%
[2]{{\bf Upon receive} (#1)$_{\text{ #2 }}${\bf from} $q$}%
{{\bf end receive}}



\newcommand{\daputdata}[2]{{\act{put-data}(#2)}}
\newcommand{\dagetdata}[1]{{\act{get-data}()}}
\newcommand{\dagettag}[1]{{\act{get-tag}()}}
\newcommand{\treas}{{\sc Treas}}
\newcommand{\oreas}{{\sc Oreas}}
\newcommand{\oreasSpace}{\oreas\hspace{2pt}}

\newcommand{\aresII}{{\sc light}\ares}
\stackMath
\newcommand\wwidehat[1]{%
	\savestack{\tmpbox}{\stretchto{%
			\scaleto{%
				\scalerel*[\widthof{\ensuremath{#1}}]{\kern-.6pt\bigwedge\kern-.6pt}%
				{\rule[-\textheight/2]{1ex}{\textheight}}%WIDTH-LIMITED BIG WEDGE
			}{\textheight}% 
		}{0.5ex}}%
	\stackon[1pt]{#1}{\tmpbox}%
}
\usepackage[symbol]{footmisc}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\newcommand{\cseq}[1]{{\wwidehat{#1}}}

\newcommand*{\dictchar}[1]{
	\clearpage
	\twocolumn[
	\centerline{\parbox[c][2cm][c]{15cm}{%
			\fontsize{18}{18}
			\selectfont
			{\center{#1}}}}]
}

\input{macros}
\input{nn_macros}

\newcommand{\lewis}[1]{{\color{red} #1}}


\begin{document}

\title{Fault-tolerant Read/Write Atomic Register with Optimized Storage in Asynchronous Networks
%\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{Yingjian Wu, Haochen Pan, Lewis Tseng}
\IEEEauthorblockA{\textit{Boston College} \\
Boston, USA\\
\{wuit, haochen.pan, lewis.tseng\}@bc.edu}
\and
\IEEEauthorblockN{Kishori M. Konwar}
\IEEEauthorblockA{\textit{Broad Institute} \\
Boston, USA\\
\lewis{???}}
\and
\IEEEauthorblockN{Muriel M\'{e}dard}
\IEEEauthorblockA{\textit{MIT}\\
Boston, USA \\
\lewis{???}}

}

\maketitle

\begin{abstract}
Cassandra is a popular NoSQL database, often used as a distributed key-value store (KV-store) in industry. To increase availability and fault-tolerance, Cassandra replicates data on multiple servers, which unfortunately wastes storage space in the case of high replication. Recently, there has been a series of efforts on integrating erasure coding (EC) with various types of KV-store to reduce storage cost. To our knowledge, there is \textit{no} EC-based protocol for Cassandra or similar quorum-based KV-stores owing to the difficulties in integrating erasure coding with quorum-based design. 
		
		In this work, we propose a EC-based protocol that achieves strong consistency with \textit{near-optimal storage cost}. 
		Our protocol supports concurrent read and write operations while tolerating asynchronous communication and crash failures of any client and some fraction of servers. 
		One novel feature of our protocol is a \textit{tunable knob} between the number of supported concurrent operations, availability, and storage cost.
		
		We implement our protocol into  Cassandra, namely CassandrEAS (Cassandra + Erasure-coding Atomic Storage). Evaluation using YCSB on Google Cloud Platform with different configurations shows that  CassandrEAS incurs moderate penalty on latency and throughput, yet saves significant amount of storage space.
\end{abstract}

\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}

\input{intro}

\bibliographystyle{plain}
\bibliography{biblio,biblio1,newbft,DSM,BFTnitin,hotcloudadd}

\end{document}
